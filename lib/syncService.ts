// lib/syncService.ts
import {
  getPendingWorkLogs,
  deletePendingWorkLog,
  PendingWorkLogData,
} from './indexedDBHelper';
// import mongoose from 'mongoose'; // Removed unused import

// Interface for the payload expected by the POST /api/worklogs endpoint
// Based on IWorkLog schema, excluding fields generated by DB (_id, createdAt, updatedAt)
// Make sure this matches what your API route expects!
interface WorkLogApiPayload {
  date: Date;
  project: string; // Expecting ObjectId string
  author: string; // Expecting ObjectId string
  workDescription: string;
  personnel: Array<{ role: string; count: number }>;
  equipment: Array<{ type: string; count: number; hours?: number }>;
  materials: Array<{ name: string; quantity: number; unit: string }>;
  // Add other optional fields from IWorkLog if they are stored/sent
  weather?: string;
  temperature?: number;
  issues?: string;
  notes?: string;
  images?: string[];
}

// Transforms data from IndexedDB format to API payload format
const transformPendingDataToApiPayload = (pendingData: PendingWorkLogData): WorkLogApiPayload => {
  // 1. Work Description
  const workDescription = `${pendingData.workType} - ${pendingData.description}`;

  // 2. Personnel: Group by role and count
  const personnelMap = new Map<string, number>();
  pendingData.personnel.forEach(p => {
    personnelMap.set(p.role, (personnelMap.get(p.role) || 0) + 1);
  });
  const personnel = Array.from(personnelMap.entries()).map(([role, count]) => ({ role, count }));

  // 3. Equipment: Group by name (type), count, and sum hours
  const equipmentMap = new Map<string, { count: number; hours: number }>();
  pendingData.equipment.forEach(e => {
    const existing = equipmentMap.get(e.name) || { count: 0, hours: 0 };
    equipmentMap.set(e.name, {
      count: existing.count + 1,
      hours: existing.hours + (e.hours || 0), // Sum hours, handle if hours is undefined
    });
  });
   const equipment = Array.from(equipmentMap.entries()).map(([type, data]) => ({
     type,
     count: data.count,
     hours: data.hours > 0 ? data.hours : undefined, // Only include hours if > 0
   }));

  // Construct the final payload
  const payload: WorkLogApiPayload = {
    date: new Date(pendingData.date), // Convert ISO string back to Date object
    project: pendingData.project,     // Already string ObjectId
    author: pendingData.author,       // Already string ObjectId
    workDescription: workDescription,
    personnel: personnel,
    equipment: equipment,
    materials: pendingData.materials, // Structure already matches
    // Include other fields if they exist in PendingWorkLogData
    // weather: pendingData.weather,
    // ...etc
  };

  return payload;
};


// Attempts to sync all pending work logs with the server
export const syncPendingWorkLogs = async (): Promise<{ successful: number; failed: number }> => {
  let successfulSyncs = 0;
  let failedSyncs = 0;

  try {
    const pendingLogs = await getPendingWorkLogs();
    console.log(`Found ${pendingLogs.length} pending work logs to sync.`);

    if (pendingLogs.length === 0) {
      return { successful: 0, failed: 0 };
    }

    // Process logs one by one
    for (const log of pendingLogs) {
      try {
        console.log(`Attempting to sync log with tempId: ${log.tempId}`);
        const apiPayload = transformPendingDataToApiPayload(log);

        const response = await fetch('/api/worklogs', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(apiPayload),
        });

        if (response.ok) { // Check for 2xx status codes
          const result = await response.json();
          console.log(`Successfully synced log tempId: ${log.tempId}, server _id: ${result._id}`);
          // Delete from IndexedDB only after successful server confirmation
          await deletePendingWorkLog(log.tempId);
          successfulSyncs++;
        } else {
          // Handle API errors (e.g., 4xx, 5xx)
          const errorBody = await response.text(); // Read error response
          console.error(`Failed to sync log tempId: ${log.tempId}. Status: ${response.status}. Error: ${errorBody}`);
          failedSyncs++;
          // Optional: Implement retry logic or mark the log as failed in IndexedDB?
          // For now, we stop syncing on the first failure to prevent hammering
          // break;
        }
      } catch (error) {
        // Handle network errors or errors during transformation/fetch
        console.error(`Error syncing log tempId: ${log.tempId}:`, error);
        failedSyncs++;
        // Optional: Implement retry logic?
        // Stop syncing on network or unexpected errors
        // break;
      }
    }
  } catch (error) {
    console.error('Failed to retrieve pending work logs:', error);
    // Can't proceed if we can't read from IndexedDB
  }

  console.log(`Sync finished. Successful: ${successfulSyncs}, Failed: ${failedSyncs}`);
  return { successful: successfulSyncs, failed: failedSyncs };
}; 